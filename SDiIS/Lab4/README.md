
Неоринтированный граф 
Способ представления: матрица смежности
Почему матрица смежности? Посчитаал её самой сложной для выполнянения т.к для каждого из итераторов необходимо переопределять операторы(и не только:) ).

Реализованы методы:
•	Проверка присутствия вершины в графе;
•	Проверка присутствия ребра между вершинами в графе;
•	Получение количества вершин;
•	Получение количества ребер;
•	Вычисление степени вершины;
•	Вычисление степени ребра;
•	Добавление вершины;
•	Добавление ребра;
•	Удаление вершины;
•	Удаление ребра;
•	Удаление вершины по итератору на вершину;
•	Удаление ребра по итератору на ребро;

А также итераторы:
•	Двунаправленный итератор для перебора вершин;
•	Двунаправленный итератор для перебора ребер;
•	Двунаправленный итератор для перебора ребер, инцидентных вершине;
•	Двунаправленный итератор для перебора вершин, смежных вершине;
•	Обратные модификации для всех итераторов;
•	Константные модификации для всех итераторов.


Для корректной работы двунаправленных итераторов необходимы были теневые вершины и ребра.Теневые ребра в матрице имеют значение -1 и рассполагаются в начале и конце соответсвующего вектора.

Теневые вершины имеют ID первого добавленного элемента, чтобы сохранить "шаблонность" класса.

Сложность данного представления графа - разная итерация. При итерировании по вершинам, нам достаточно просто переходить к следующей вершине. При итерировании по ребрам, нам необходимо иксать "единицы". Поэтому и нельзя было изпользовать шаблон для итераторов.

Схожие итераторы(например, Iterator_edges и Iterator_reverse_edges) наследуются один из другого(Iterator_edges <= Iterator_reverse_edges). Для чего? для работы методов удаления по итераторам в единоличном экземпляре(хоть у меня и 2 экземпляра на каждого, один для обычного и обратного, другой для констатного)



